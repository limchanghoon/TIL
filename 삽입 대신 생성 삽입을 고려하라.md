# 삽입 대신 생성 삽입을 고려하라

다음은 삽입 함수 push_back(insert, push_front; std::forward_list는 insert_after )은 매개변수 형식이 일치하지 않는 경우 수행되는 절차이다.

1. 형식에 맞는 임시 객체가 생성됨 (오른값), 이 임시 객체를 temp라고 하자.
2. 오른값 오버로딩 함수에 전달됨. 이것을 x 라고 하자. 
3. 삽입하려는 컨테이너에 x의 복사본을 생성한다.
4. 삽입 함수 반환시 temp가 파괴됨. (소멸자 실행)

여기서 임시 객체를 바로 컨테이너에 삽입하면 효율적일 것이다. 그것이 바로 `emplace_back`으로 실현된다. (완벽 전달 형식이다.) **삽입 함수**는 **삽입할 객체**를 받는다. **생성 삽입 함수**는 **삽입할 객체의 생성자를 위한 인수**를 받는다. 거의 **생성 삽입 함수**가 빠른 성능을 보이지만 `그렇지 않은 경우`도 존재한다.

1. **템플릿 형식과 인수의 형식이 같은 경우** : 형식이 같으면 임시 객체의 생성 - 소멸은 일어나지 않는다.
2.  **배정을 통해 삽입하는 경우** : 이동 배정을 수행하려면 이동의 원본이 필요해 임시 객체를 생성해야돼서 생성 삽입 함수의 이득이 없다. **노드 기반 컨테이너**들은 거의 항상 **삽입**을 통해 추가한다. 그 외에 컨테이너는 3가지 밖에 존재하지 않는다. ***(std::vector, std::deque, std::string)*** 이 컨테이너들의 ***emplace*** 함수가 배정을 사용하고, ***emplace_back*** 의 경우에는 **생성**을 사용한다. 
3. **기존 값과의 중복을 허락하지 않거나 고유한 값인 경우(std::map)** : 이런 경우 삽입시 새 값으로 노드를 생성하고  컨테이너에 중복값을 비교해 없으면 추가, 있으면(중복되면) 노드를 삭제한다. 이 노드 삭제 부분의 비용부담이 큰데, 이런 경우는 **생성 삽입 함수**에서 자주 일어난다.

또한 다음은 `생성 삽입의 문제점`들이다.

- **스마트 포인터를 삽입할 때 예외 발생시 자원 누수 : `그냥 삽입 함수`는 임시 객체를 사용하기 때문에 **std::shared_ptr**같은 객체를 넣을 때 예외가 발생해도 임시 객체의 소멸자가 ptr에 넣은 어떠한 객체의 삭제자까지 실행되면서 누수가 일어나지 않는다. 하지만 `생성 삽입 함수`는 예외발생시 함수 밖으로 전파되면서, ptr에 넣은 어떠한 객체에 포인터가 사라져, 결국 객체가 누수된다.

- **explicit 생성자들에서 explicit을 무시함** : 

  - ```c++
    std::regex r1 = nullptr;		// 복사 초기화; explicit 작용!
    std::regex r2(nullptr);			// 직접 초기화; explicit 무시함!
    ```

  - ```c++
    regexes.push_back(nullptr);		// 복사 초기화; explicit 작용!
    regexes.emplace_back(nullptr);	// 직접 초기화; explicit 무시함!
    ```

