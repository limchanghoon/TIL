# 스레드 기반 프로그래밍보다 과제 기반 프로그래밍을 선호하라

함수를 비동기적으로 실행하는 방법은 `std::thread` 객체를 생성하는 `스레드 기반`과 `std::async` 객체를 생성하는 `과제 기반` 프로그래밍이 있다.

`std::aysnc`을 이용해 생성한 객체를  `future`객체라고 한다. `스레드`를 사용하면 그 스레드로 받아온 함수의 반환값에 접근할 수 없지만, `future 객체`는 거기에 받아온 함수의 반환값에 접근할 수 있다. 또한 예외가 발생해도 접근이 가능하다.

## 스레드

- **하드웨어 스레드** : 실제 계산을 수행하는 스레드 . CPU 코어당 하나 이상의 하드웨어 스레드를 제공.
- **소프트웨어 스레드** : 운영체제가 하드웨어 스레드들에서 실행되는 모드 프로세서와 일정을 관하는 데 사용하는 스레드 . OS스레드나 시스템 스레드라고도 한다. 대체로, 하드웨어 스레드보다 많은 스레드 생성. 한 소프트웨어 스레드가 차단되면 다른 스레드를 실행시킨다.
- **std::thread** : c++ 표준 라이브러리로 바탕 소프트웨어 스레드에 대한 핸들로 작용한다. 어떠한 소프트웨어 스레드에도 대응되지 않을 수도 있다.

**소프트웨어 스레드**는 제한된 자원이다. **소프트웨어 스레드**가 너무 많아지면 ***std::thread*** 를 생성할 때 예외가 발생한다. 또한 실행 준비가 된(즉, 차단되지 않은)**소프트웨어 스레드**가 **하드웨어 스레드**보다 많아지는 경우에 **oversubscription**이 발생한다. 그러면 **context switch** 가 발생하는 상황이 많아지고, CPU 캐시는 유용하지 않게 되고 다음 스레드가 사용할 캐시 또한 오염되어 버린다.  **과다구독**을 피하기는 어렵다. 하지만 이러한 해결을 **std::async**에게 떠넘기면 편해진다.

```c++
auto fut = std::async(doAsyncWork);
```



## std::async

**std::async**가 새 소프트웨어 스레드를 생성하지 않을 수 있다. 이것이 부하문제가 아예 사라지지는 않지만 실행 스케줄러가 상당히 관리를 해준다. 

하지만 GUI 스레드의 반응성 문제는 여전하다. 이때는 `std::launch::async`라는 **시동 방침**을 **std::async**에 넘겨주는 것이 바람직하다.



## 스레드를 직접 다루는 게 적합한 경우

- 바탕 스레드(소프트웨어 스레드) 적용 라이브러리의 API에 접근해야 하는 경우
- 응용 프로그램의 스레드 사용량을 최적화해야 하는, 그리고 할 수 있어야 하는 경우
- C++ 동시성 API가 제공하는 것 이상의 스레드 적용 기술을 구현해야 하는 경우
