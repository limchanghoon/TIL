# 항목29. 이동 연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라

복사를 실행하는 C++98코드 기반을 C++11을 준수하는 컴파일러와 표준 라이브러리로 컴파일하면 소프트웨어가 저절로 더 빠르게 실행된다.

하지만 다음의 경우들은 지원하지 않는다.

- 사용하는 라이브러리가 이동을 지원하지 않는 경우.
- 이동 연산을 명시적으로 선언하지 않았을 때 이동 연산이 자동으로 지원되지 않는 경우. 이는 형식에 복사 연산이나 이동 연산, 소멸자가 하나라도 있으면 그러한 자동 작성은 일어나지 않는다. (항목 17) 또한 이동 연산을 삭제(비활성)한 경우도 포함.

다음 경우는 이동 의미론이 도움이 되지 않는 경우이다.

- 이동할 객체가 이동 연산들을 제공하지 않는 경우. 이 경우 이동 요청은 복사 요청이 된다.

- 이동할 객체의 이동 연산이 해당 복사 연산보다 빠르지 않은 경우.

- 이동이 일어나려면 이동 연산이 예외를 방출하지 않아야 하는 문맥에서, 해당 연산이 noexcept로 선언되어 있지 않은 경우.(표준 라이브러리의 일부 컨테이너 연산들은 강한 예외 안전성을 보장한다. 즉 해당 이동 연산이 noexcept로 선언되어 있지 않으면 복사 연산이 호출된다.)

- 오직 오른값만 이동 연산의 원본이 될 수 있는 경우에 원본 객체가 왼값인 경우.



결과적으로 코드에서 사용하는 형식을 구체적으로 알지 못하는 경우엔 대체로 이동이 적용되지 않는다고 가정해라. 일반적인 코드, 이를테면 템플릿을 작성할 때가 그런 경우이다.

하지만 코드가 사용하는 구체적인 형식들을 미리 알 수 있는, 그리고 그 형식들의 특징이 바뀌지 않으리라고 확신할 수 있는 경우에 복사보다 저렴한 이동 연산을 제공한다면 적극 활용하라!
