# 람다 표현식, 기본 캡처(갈무리) 모드를 피하라

### 람다 표현식

- 기본 형식 : [] (변수형 val) { return returnVal}

  람다에서 캡처부분에 변수는 로컬변수로, 람다의 바디에서 사용할 수 있다. 명시적이지 않은 기본 캡처는 다 받을 수 있다.

  [&] : 참조에 의한 캡처

  [=] : 값에 의한 캡처. const(읽기 전용) 속성으로 가져온다.

  [로컬변수] : 명시적으로 특정 로컬 변수를 값으로 가져온다.

  [&로컬변수] : 명시적으로 특정 로컬 변수를 참조로 가져온다.

  클래스의 멤버 변수를 람다의 바디 안에서 사용할 때는 this->가 생략되어 있다.

- 람다표현식 : std::function이 가리키는(호출되는) 함수의 내용을 즉석에서 구현한 것
- 클로저 : 람다 함수가 만든 실행시점 std::function 객체

기본 캡처 모드는 참조에 의한 캡처와 값에 의한 캡처가 있다.

참조에 의한 캡처는 그 참조를 받아온 지역 변수의 범위(함수 등)이 끝나면 지역 변수는 사라져 참조 대상을 잃는다.

값에 의한 캡처는 생략된 `this->`에 의해서 결국 해당 객체의 수명이 끝나면 또한 대상을 잃는다.

이때 캡처에 넣어 사용하려는 로컬 자료 멤버를 복사해 그 복사본을 캡처하면 잘 작동한다. 하지만 위험을 자초할 필요는 없으니 기본 캡처는 피하자.

명시적이지 않은 기본 캡처는 아무것도 캡처하지 않아도 캡처하듯 혼동을 줄 수 있다. 캡처가 필요없는 전역 범위나 이름 범위에서 정의된 객체와 클래스, 함수, 파일 안에서의 static으로 선언된 객체는 람다에서 사용이 가능하지만 캡처할 수는 없다.