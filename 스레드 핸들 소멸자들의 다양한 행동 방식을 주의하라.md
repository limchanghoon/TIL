# 스레드 핸들 소멸자들의 다양한 행동 방식을 주의하라

**합류 가능 스레드**는 시스템 스레드에 대응하고, **미래 객체**도 시스템 스레드에 대응한다. 둘다 시스템 스레드에 대한 **핸들**이라고 할 수 있다.

미래객체는 스레드같이 **암묵적 join**과 **암묵적 detach**와 비슷한 행동을 한다. 하지만 스레드와는 다르게 프로그램 종료나 미정의 행동을 하지는 않는다. 이 차이를 알기 위해 스레드의 행동 방식을 살펴보자

### 스레드의 행동 방식

#### 공유 상태

스레드의 결과가 저장되는 공간을 `공유 상태`라고 한다. 공유 상태는 미래 객체(호출자)와 스레드(피호출자)의 바깥에 있는 새로운 공간이다. 여기에 저장하는 이유는, `미래 객체`의 경우 **std::shared_future**를 통해 복사하면 결과를 저장할 공간을 이 중에 특정할 수 없다.(복사를 지원하지 않는 결과의 경우) `스레드`의 경우 `std::promise`객체를 기록한다. 이 객체에 저장한다면 수명이 스레드의 수명과 같아진다. 만약 스레드가 종료된 이후에 미래객체의 **get**을 통해 결과를 얻어오려고 하면 수명이 끝난 것을 얻어와 미정의 행동을 유발한다.

이 `공유 상태`가 중요한 이유는 `미래 객체 소멸자`의 행동을 결정하기 때문이다.

- **마지막** 남은 **미래 객체**가 `std::async`호출로 생성된 **공유 상태**를 참조한다면, 비동기적으로 실행되는 해당 스레드에 **암묵적 join**을 수행한다. 즉, 비동기적인 과제가 끝날 때까지 미래 객체의 **소멸자는 지연**된다.
- 그 이외의 미래 객체는 **해당 객체만** 파괴한다.(암묵적 join 안함)

std::async 호출에서 비롯된 경우가 아니라도 공유 상태가 생성될 수 있다. 이는 `std::packaged_task`을 사용할 때이다.

`std::packaged_task`을 활용해 **암묵적 join**에 의한 지연 문제의 해결할 수도 있다.

```c++
int calValue();		// 실행할 함수
...

{
    std::packaged_task<int()> pt(calValue);		// 비동기적 실행을 위해 calValue를 포장한다.
    auto fut = pt.get_future();					// pt에 대한 미래 객체를 얻는다.
    std::thread t(std::move(pt));	// std::packaged_task 객체는 복사할 수 없으므로, 오른값으로 캐스팅해야 한다.
    ...		// 아래 설명 참고
}
```

중요한 것은 **"..."**부분에 스레드 t에 대해 어떤 행동을 하는 가이다.

- **아무 것도 수행하지 않는 경우**

  스레드가 소멸될 때, 해당 스레드 t는 **합류 가능 스레드**이다. 따라서 프로그램이 종료된다. 

- **join을 수행하는 경우**

  여기서 스레드에 join을 한다면 future 객체는 소멸될 때, 아무런 행동을 할 필요가 없다.

- **detach를 수행하는 경우**

  여기서 스레드에 detach를 한다면 future 객체는 소멸될 때, 아무런 행동을 할 필요가 없다.

따라서, `std::packaged_task`에 의해 만들어진 공유 상태를 참조하는 미래 객체의 소멸자의 행동을 고려할 필요가 없다. 대신 스레드를 조작하는 코드에서 **join**이든 **detach**를, 혹은 종료를 정하기 때문이다.
