# 동시성에는 std::atomic을 사용하고, volatile(휘발성)은 특별한 메모리에 사용하라

**std::atomic**으로 선언한 변수는 증가, 감소, 읽기-수정 등이 **원자적**으로 이루어진다. 또한 **atomic**으로 생성한 객체에 대한 모든 멤버 함수는 다른 스레드에게 원자적으로 보인다. 원자적인 특성때문에 복사 연산들도 불가하다(제거됨). 반면 `volatile`로 선언한 변수는 다른 스레드가 읽으면 `자료 경쟁`이 발생해 **미정의 행동**이 일어날 수 있다. 

volatile의 미정의 행동의 예를 들면, volatile 변수를 0으로 초기화하고 1씩 증가시키는 스레드 1과 스레드 2를 동시에 실행시키면, 2가지 경우중 하나가 된다.

1. 스레드 1이 0을 읽고 1로 증가시키고 쓰기,스레드2가 1을 읽고 2로 증가시키고 쓰기 => 결과 : 2
2. 스레드 1이 0을 읽고 스레드 2가 0을 읽음. 스레드 1이 1로 증가시키고 쓰기, 스레드 2가 1로 증가시키고 쓰기 => 결과 : 1

`std::atomic`은 배정문들의 순서를 바꾸지 않는다. 하지만 `volatile`은 그런 특수성이 없다.

## 메모리 대응 입출력-volatile

보통 컴파일러는 읽고거나 쓰고나서 사용하지 않고 다시 같은 행위를 하면 이런 불필요한 부분을 제거하는 기능이 있다. 하지만 **메모리 대응 입출력**에 쓰이는 메모리에 대한 접근은 보통의 메모리에서 행해지는 것과 다르다. 불필요해 보이는 행위가 여기서는 필요한 것이다. 이럴 때 사용하는 것이 `volatile`이다. 이는 `"이 메모리에 대한 여산들에는 그 어떤 최적화도 수행하지 마라!"` 라는 지시이다.



# 결론 및 요약

- **std::atomic** : 뮤텍스 보호 없이 여러 스레드가 접근하는 자료를 위한 것, 동시적 소프트웨어의 작성을 위한 도구이다. 배정문의 순서를 바꾸지 않고 코드 최적화가 일어날 수 있다.
- **volatole** : 읽기와 기록을 최적화로 제거하지 말아야 하는 메모리를 위한 것으로, 특별한 메모리를 다룰 때 필요한 도구이다.